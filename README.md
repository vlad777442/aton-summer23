# aton-summer23
# Test task for Aton

### 1. Тестовое задание для стажера Java-разработчика в команду корпоративной шины данных и микосервисов

In memory simple DB

В процессе реализации сервиса проверки данных возникла необходимость в
организации  in memory кэша с возможностью быстрого поиска по разным полям.

Структура данных представлена следующим набором полей:
```bash
{
"account": "234678", //long
"name": "Иванов Иван Иванович", //string
"value": "2035.34" //double
}
```
Количество записей заранее не определено и может меняться динамически.

ВОПРОС: Необходимо организовать хранение этих записей в памяти с
соблюдением требований:
1. предоставить возможность добавлять новые записи;
2. предоставить возможность удалять более не нужные записи;
3. предоставить возможность изменять запись;
4. получать полный набор записи по любому из полей с одинаковой
   алгоритмической сложностью (не медленнее log(n));
5. выбрать наиболее экономный способ хранения данных в памяти.

#### Решение представлено в папке AtonTask1.

Для реализации функциональности по добавлению, удалению, обновлению и поиску записей
можно использовать структуру данных HashMap, которая обеспечивает
доступ к элементам по ключу. В качестве ключа может использоваться номер счета.

Для поиска записей по имени и значению можно использовать дополнительные HashMap,
которые связывают имя и значение с соответствующим списком записей. Это позволяет
эффективно находить все записи с заданным именем.
Такую же структуру можно использовать для значений.

Временная сложность доступа и вставки элемента в HashMap составляет O(1).

В других случаях также можно использовать оптимизированные алгоритмы для поиска записей по имени
и значению, например, алгоритмы хеширования и сортировки.


### 2. Тестовое задание для стажера Java-разработчика в команду технологий фонт-офиса

#### Задание 1. 
Надо написать программу, в которой 6 тредов: Chandler, Joey, Monica, Phoebe, Rachel и Ross разыгрывают в консоли сценки из ситкома.

#### Решение представлено в папке AtonTask1FontOffice.

#### Задание 2.
Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн. заказов некоторого сервиса
доставки еды за некоторый период 2021 и 2022 года.
Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента, а
средняя длина полного имени - 20 символов (латинских или кириллических).
Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента. Но вы не
хотите оставлять следы на диске или в базе данных - придется все держать в памяти. Но еще вы не хотите зря тратить
крипту на слишком большой сервер.

Поэтому давайте оценим, сколько памяти займут эти данные:
* если мы хотим реализовать поиск за постоянное время, т.е. O(1)?
* если мы хотим занять как можно меньше памяти?

#### Решение:

Если мы хотим реализовать поиск за постоянное время O(1), то можно
использовать структуру HashMap, так как она хранит данные по ключу,
а номер телефона у каждого абонента индивидуальный. В данном случае в качестве
ключа будет номер телефона (Long), а значением полное имя владельца (String). 


* Размер ключа Long - 8 байт;
* Размер String - 20 символов по 2 байта = 40 байт;
* HashMap Entry - 32 байта;
* HashMap Node - 24 байта.
```
18 758 328 * (8 + 40 + 32 + 24) = 2 334 791 168 байт (около 2.3 Гб)
```

Если мы хотим занять как можно меньше памяти, то можно использовать
структуру данных, которая хранит данные в отсортированном
порядке. Это позволяет быстро искать нужное значение. Одним из вариантов является
дерево поиска (TreeMap). Номер телефона будет ключом, имя клиента - значением.

Таким образом, для хранения данных в TreeMap потребуется примерно:
* Размер ключа Long - 8 байт;
* Размер String - 20 символов по 2 байта = 40 байт;
* TreeMap Entry - 48 байт.
```
18 758 328 * (8 + 40 + 48) = 1 177 085 984 байт (около 1.2 Гб)
```
Также  необходимо учитывать дополнительную память,
занимаемую самой структурой данных и дополнительной логикой.